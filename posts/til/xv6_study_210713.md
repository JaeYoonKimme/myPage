---
title: 'Xv6_study_210713'
date: '2021-07-13'
---

# Day2  
어제에 이어서 xv6 운영체제가 실행되는 과정을 살펴보았다. 

<br>

1. bootmain.c 코드는, ELF 파일 형식의 커널을 메모리에 올리는 파트인데, 코드를 살펴보고, ELF 파일이 어떤 식으로 정렬되어 있는지도 알아보았다. readelf 라는 명령어를 사용하면, 해당 elf 파일에 대한 정보를 확인할 수 있었다. 혹은 objdump 명령어로도 elf파일 이미지를 뜯어볼 수있었다. 이 명령어를 통해서 커널 이미지를 뜯어보면, .text, .rodata, .data 등등을 볼수있다. 여기서 LMA 와 VMA 가 나오는데, LMA 실제로 데이터가 load 된 주소이고. VMA 는 해당 데이터가 실행되는 주소로 physical address 와 virtual address의 관계로 이해했다. 
<br>

2. exercise 5는 커널에서 paging hardware가 언제 활성화 되는지를 알아보는 문제였다. 이것을 위해서, 책의 흐름을 따라가며 커널의 시작 부분인 entry.S 코드를 살펴보았다. 커널이 처음 시작된 시점에서는, 페이징 하드웨어가 아직 활성화 되지 않았기 떄문에, virtual address와 physical address가 direct하게 매핑되어있다. entry 에서 활성화하게 되는 페이지 테이블 엔트리는 0 과 512 가 있는데, 0번은 entry부분이 실행될때만 사용되는 부분이고, 512번이 entry.S 가 끝나고 난 후에 사용된다. entry에서 페이징 하드웨어를 활성화 하는것 외에도, 스택 포인터를 세팅하는 부분이 있는데, 이 부분은 아직 제대로 살펴보지 못했다. 
<br>

3. 주어진 내용들을 읽는 동안, 이해되지 않는 부분이 많았다. 내가 어떤 정보가 없어서 이해가 안되는지 파악해서 찾고 공부하고 싶었지만, 잘 하지 못했다. 쫒기듯이 이것 저것 보기보다는 내가 모르는것이 있으면 인정하고 천천히 살펴보도록 해야겠다. 내가 모르는 것을 찾고, 그것을 얻어가는 과정을 연습한다는 마음으로 임해야 겠다. 